name: Build, Deploy, and Stress Test on week7 branch

on:
  push:
    branches: [ week7 ]

env:
  # Common environment variables
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER }}
  GKE_ZONE: ${{ secrets.GKE_ZONE }}
  GAR_LOCATION: ${{ secrets.GAR_LOCATION }}
  GAR_REPOSITORY: "iris-app-repo" # Name of your Artifact Registry repository
  APP_NAME: "iris-predictor-api"

jobs:
  build-deploy-and-test:
    name: Build, Deploy, and Stress Test
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    # 1. Authenticate to Google Cloud
    - name: Authenticate to Google Cloud
      id: auth
      uses: 'google-github-actions/auth@v1'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    # 2. Configure Docker for Artifact Registry
    - name: Configure Docker
      run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev

    # 3. Build and Push Docker image
    - name: Build and Push Docker image
      run: |
        # Define the full image tag
        IMAGE_TAG="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.APP_NAME }}:${{ github.sha }}"
        
        # Build the Docker image
        docker build -t $IMAGE_TAG .
        
        # Push the Docker image to Google Artifact Registry
        docker push $IMAGE_TAG
        
        # Make the image tag available to subsequent steps
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

    # 4. Set up GKE credentials
    - name: Set up GKE credentials
      uses: 'google-github-actions/get-gke-credentials@v1'
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GKE_ZONE }}
        project_id: ${{ env.GCP_PROJECT_ID }}

    # 5. Deploy to Google Kubernetes Engine
    - name: Deploy to GKE
      run: |
        echo "Deploying image ${{ env.IMAGE_TAG }} to GKE cluster ${{ env.GKE_CLUSTER }}"
        
        # Use sed to replace the placeholder image with the new image tag in the deployment manifest
        sed -i "s|image:.*|image: ${{ env.IMAGE_TAG }}|g" k8s/deployment.yaml

        # Apply the updated manifest to the cluster. This handles both creation and updates.
        kubectl apply -f k8s/deployment.yaml
        
        # Wait for the deployment rollout to complete
        kubectl rollout status deployment/${{ env.APP_NAME }}
        echo "Deployment successful!"

    # 6. Get Service External IP
    - name: Get Service External IP
      id: get_ip
      run: |
        echo "Waiting for external IP..."
        EXTERNAL_IP=""
        while [ -z $EXTERNAL_IP ]; do
          EXTERNAL_IP=$(kubectl get service ${{ env.APP_NAME }}-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          [ -z "$EXTERNAL_IP" ] && sleep 10
        done
        echo "Obtained external IP: $EXTERNAL_IP"
        echo "IP=$EXTERNAL_IP" >> $GITHUB_OUTPUT

    # 7. Install wrk for stress testing
    - name: Install wrk
      run: |
        sudo apt-get update
        sudo apt-get install -y wrk

    # 8. Stress Test with Autoscaling (max 3 pods)
    - name: Stress Test with Autoscaling
      run: |
        echo "--- Starting Stress Test (max pods: 3, concurrency: 1000) ---"
        # Run wrk to generate load
        wrk -t4 -c1000 -d30s http://${{ steps.get_ip.outputs.IP }}/
        
        echo "--- Observing HPA status during test ---"
        # Watch HPA during the test in the background
        kubectl get hpa -w &
        sleep 35
        kill $!
        
        echo "--- Final HPA and Pod status ---"
        kubectl get hpa
        kubectl get pods

    # 9. Restrict Autoscaling and Observe Bottlenecks
    - name: Restrict Autoscaling and Observe Bottlenecks
      run: |
        echo "--- Restricting max pods to 1 for bottleneck test ---"
        kubectl patch hpa ${{ env.APP_NAME }}-hpa --patch '{"spec":{"maxReplicas":1}}'
        
        # Wait for any extra pods to terminate
        echo "Waiting for cluster to scale down..."
        sleep 30
        
        echo "--- Starting Bottleneck Test (max pods: 1, concurrency: 2000) ---"
        # Run wrk with increased concurrency
        wrk -t4 -c2000 -d30s http://${{ steps.get_ip.outputs.IP }}/
        
        echo "--- Final HPA and Pod status after bottleneck test ---"
        kubectl get hpa
        kubectl get pods
